#include <stdio.h>

#define MOD 1000000007

// Directions: up, down, left, right
int dir[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};

// Recursive helper function with memoization
int findPathsUtil(int m, int n, int N, int i, int j, int dp[51][51][51]) {
    if (i < 0 || j < 0 || i >= m || j >= n)
        return 1;  // Ball is out of boundary
    if (N == 0)
        return 0;  // No more moves left

    if (dp[i][j][N] != -1)
        return dp[i][j][N];  // Use memoized result

    long long paths = 0;
    for (int d = 0; d < 4; d++) {
        int x = i + dir[d][0];
        int y = j + dir[d][1];
        paths += findPathsUtil(m, n, N - 1, x, y, dp);
        paths %= MOD;
    }

    dp[i][j][N] = paths;
    return dp[i][j][N];
}

int findPaths(int m, int n, int N, int i, int j) {
    static int dp[51][51][51];
    // Initialize dp with -1
    for (int a = 0; a < 51; a++)
        for (int b = 0; b < 51; b++)
            for (int c = 0; c < 51; c++)
                dp[a][b][c] = -1;

    return findPathsUtil(m, n, N, i, j, dp);
}

int main() {
    int m, n, N, i, j;

    // Example 1
    m = 2; n = 2; N = 2; i = 0; j = 0;
    printf("Input: m=%d, n=%d, N=%d, i=%d, j=%d\n", m, n, N, i, j);
    printf("Output: %d\n\n", findPaths(m, n, N, i, j));

    // Example 2
    m = 1; n = 3; N = 3; i = 0; j = 1;
    printf("Input: m=%d, n=%d, N=%d, i=%d, j=%d\n", m, n, N, i, j);
    printf("Output: %d\n", findPaths(m, n, N, i, j));

    return 0;
}
